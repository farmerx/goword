// Copyright 2021 - 2021 The goword Authors. All rights reserved. Use of
// this source code is governed by a MIT license that can be found in
// the LICENSE file.
//
// Package goword providing a set of functions that allow you to write to
// and read from DOCX files. Supports reading and writing
// wordprocessing documents generated by Microsoft Wordâ„¢ 2007 and later.
// This library needs Go version 1.15 or later.

package goword

import (
	"archive/zip"
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"sync"

	"golang.org/x/net/html/charset"
)

// charsetTranscoderFn define for charset transfer code function
type charsetTranscoderFn func(charset string, input io.Reader) (reader io.Reader, err error)

// Options define the options for open wordprocessing.
type Options struct {
	Password string
}

// File define a populated wordprocessing file struct.
type File struct {
	sync.Mutex
	options       *Options
	ContentTypes  *contentTypes
	Relationships sync.Map
	Package       sync.Map
	CharsetReader charsetTranscoderFn
}

// OpenFile take the name of an wordprocessing file and returns a populated spreadsheet file struct
// for it. For example, open wordprocessing with password protection:
//
//    f, err := goword.OpenFile("demo.docx", goword.Options{Password: "password"})
//    if err != nil {
//        return
//    }
//
// Note that the goword just support decrypt and not support encrypt currently, the wordprocessing
// saved by Save and SaveAs will be without password unprotected.
func OpenFile(filepath string, opt ...Options) (*File, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	return OpenReader(file, opt...)
}

func newFile() *File {
	return &File{
		Relationships: sync.Map{},
		CharsetReader: charset.NewReaderLabel,
	}
}

func OpenReader(r io.Reader, opt ...Options) (*File, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}
	f := newFile()
	if bytes.Contains(b, oleIdentifier) && len(opt) > 0 {
		for _, o := range opt {
			f.options = &o
		}
		b, err = Decrypt(b, f.options)
		if err != nil {
			return nil, fmt.Errorf("decrypted file failed")
		}
	}

	zipr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return nil, err
	}
	file, err := ReadZipReader(zipr)
	if err != nil {
		return nil, err
	}
	for k, v := range file {
		f.Package.Store(k, v)
	}
	return f, nil
}

// CharsetTranscoder Set user defined codepage transcoder function for open
// DOCX from non UTF-8 encoding.
func (f *File) CharsetTranscoder(fn charsetTranscoderFn) *File { f.CharsetReader = fn; return f }

// Creates new XML decoder with charset reader.
func (f *File) xmlNewDecoder(reader io.Reader) *xml.Decoder {
	decoder := xml.NewDecoder(reader)
	decoder.CharsetReader = f.CharsetReader
	return decoder
}
