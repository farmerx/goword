// Copyright 2021 - 2021 The goword Authors. All rights reserved. Use of
// this source code is governed by a MIT license that can be found in
// the LICENSE file.
//
// Package goword providing a set of functions that allow you to write to
// and read from DOCX files. Supports reading and writing
// wordprocessing documents generated by Microsoft Wordâ„¢ 2007 and later.
// This library needs Go version 1.15 or later.

package goword

import (
	"archive/zip"
	"bytes"
	"io"
	"os"
	"sync"
)

// NewFile provides a function to create new file by default template. For
// example:
//
//    f := NewFile()
//
func NewFile() *File {
	f := newFile()
	f.Package.Store("[Content_Types].xml", []byte(XMLHeader+templateContentTypes))
	f.Package.Store("_rels/.rels", []byte(XMLHeader+templateRels))
	f.Package.Store("docProps/app.xml", []byte(XMLHeader+templateDocpropsApp))
	f.Package.Store("docProps/core.xml", []byte(XMLHeader+templateDocpropsCore))
	f.Package.Store("word/_rels/document.xml.rels", []byte(XMLHeader+templateDocumentRels))
	f.Package.Store("word/theme/theme1.xml", []byte(XMLHeader+templateTheme))
	f.Package.Store("word/styles.xml", []byte(XMLHeader+templateStyles))
	f.Package.Store("word/document.xml", []byte(XMLHeader+templateDocument))
	f.Package.Store("word/settings.xml", []byte(XMLHeader+templateSettings))
	f.Relationships = sync.Map{}
	return f
}

// SaveAs provides a function to create or update to an spreadsheet at the
// provided path.
func (f *File) SaveAs(name string, opt ...Options) error {
	if len(name) > MaxFileNameLength {
		return ErrMaxFileNameLength
	}
	file, err := os.OpenFile(name, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer file.Close()
	f.options = nil
	for _, o := range opt {
		f.options = &o
	}
	return f.Write(file)
}

// Write provides a function to write to an io.Writer.
func (f *File) Write(w io.Writer) error {
	_, err := f.WriteTo(w)
	return err
}

// WriteTo implements io.WriterTo to write the file.
func (f *File) WriteTo(w io.Writer) (int64, error) {
	if f.options != nil && f.options.Password != "" {
		buf, err := f.WriteToBuffer()
		if err != nil {
			return 0, err
		}
		return buf.WriteTo(w)
	}
	if err := f.writeDirectToWriter(w); err != nil {
		return 0, err
	}
	return 0, nil
}

// WriteToBuffer provides a function to get bytes.Buffer from the saved file. And it allocate space in memory. Be careful when the file size is large.
func (f *File) WriteToBuffer() (*bytes.Buffer, error) {
	buf := new(bytes.Buffer)
	zw := zip.NewWriter(buf)

	if err := f.writeToZip(zw); err != nil {
		return buf, zw.Close()
	}

	if f.options != nil && f.options.Password != "" {
		if err := zw.Close(); err != nil {
			return buf, err
		}
		b, err := Encrypt(buf.Bytes(), f.options)
		if err != nil {
			return buf, err
		}
		buf.Reset()
		buf.Write(b)
		return buf, nil
	}
	return buf, zw.Close()
}

// writeDirectToWriter provides a function to write to io.Writer.
func (f *File) writeDirectToWriter(w io.Writer) error {
	zw := zip.NewWriter(w)
	if err := f.writeToZip(zw); err != nil {
		zw.Close()
		return err
	}
	return zw.Close()
}

// writeToZip provides a function to write to zip.Writer
func (f *File) writeToZip(zw *zip.Writer) error {
	var err error
	f.Package.Range(func(path, content interface{}) bool {
		if err != nil {
			return false
		}
		var fi io.Writer
		fi, err = zw.Create(path.(string))
		if err != nil {
			return false
		}
		_, err = fi.Write(content.([]byte))
		return true
	})
	return err
}
