// Copyright 2021 - 2021 The goword Authors. All rights reserved. Use of
// this source code is governed by a MIT license that can be found in
// the LICENSE file.
//
// Package goword providing a set of functions that allow you to write to
// and read from DOCX files. Supports reading and writing
// wordprocessing documents generated by Microsoft Wordâ„¢ 2007 and later.
// This library needs Go version 1.15 or later.

package goword

import (
	"archive/zip"
	"bytes"
	"io"
	"strings"
)

// ReadZipReader can be used to read the wordprocessing in memory without touching the
// filesystem.
func ReadZipReader(r *zip.Reader) (map[string][]byte, error) {
	var err error
	var docPart = map[string]string{
		"[content_types].xml": "[Content_Types].xml",
	}
	fileList := make(map[string][]byte, len(r.File))
	for _, v := range r.File {
		fileName := strings.Replace(v.Name, "\\", "/", -1)
		if partName, ok := docPart[strings.ToLower(fileName)]; ok {
			fileName = partName
		}
		if fileList[fileName], err = readFile(v); err != nil {
			return nil, err
		}
	}
	return fileList, nil
}

// Read file content as string in a archive file.
func readFile(file *zip.File) ([]byte, error) {
	rc, err := file.Open()
	if err != nil {
		return nil, err
	}
	defer rc.Close()
	dat := make([]byte, 0, file.FileInfo().Size())
	buff := bytes.NewBuffer(dat)
	if _, err := io.Copy(buff, rc); err != nil {
		return nil, err
	}
	return buff.Bytes(), nil
}

// readXML provides a function to read XML content as string.
func (f *File) readXML(name string) []byte {
	if content, _ := f.Package.Load(name); content != nil {
		return content.([]byte)
	}
	return []byte{}
}

// saveFileList provides a function to update given file content in file list
// of XLSX.
func (f *File) saveFileList(name string, content []byte) {
	newContent := make([]byte, 0, len(XMLHeader)+len(content))
	newContent = append(newContent, []byte(XMLHeader)...)
	newContent = append(newContent, content...)
	f.Package.Store(name, newContent)
}

// namespaceStrictToTransitional provides a method to convert Strict and
// Transitional namespaces.
func namespaceStrictToTransitional(content []byte) []byte {
	var namespaceTranslationDic = map[string]string{
		//StrictSourceRelationship:               SourceRelationship.Value,
		//StrictSourceRelationshipOfficeDocument: SourceRelationshipOfficeDocument,
		//StrictSourceRelationshipChart:          SourceRelationshipChart,
		//StrictSourceRelationshipComments:       SourceRelationshipComments,
		//StrictSourceRelationshipImage:          SourceRelationshipImage,
		//StrictNameSpaceSpreadSheet:             NameSpaceSpreadSheet.Value,
	}
	for s, n := range namespaceTranslationDic {
		content = bytesReplace(content, []byte(s), []byte(n), -1)
	}
	return content
}

// bytesReplace replace old bytes with given new.
func bytesReplace(s, old, new []byte, n int) []byte {
	if n == 0 {
		return s
	}

	if len(old) < len(new) {
		return bytes.Replace(s, old, new, n)
	}

	if n < 0 {
		n = len(s)
	}

	var wid, i, j, w int
	for i, j = 0, 0; i < len(s) && j < n; j++ {
		wid = bytes.Index(s[i:], old)
		if wid < 0 {
			break
		}

		w += copy(s[w:], s[i:i+wid])
		w += copy(s[w:], new)
		i += wid + len(old)
	}

	w += copy(s[w:], s[i:])
	return s[0:w]
}
